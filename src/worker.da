import xml.etree.ElementTree as ET
import os
import sys
import queue
THIS_DIR = os.path.dirname(os.path.realpath(__file__))
sys.path.append(THIS_DIR + "/..")
from config import master_config
common = import_da('common')

class Result:
    def __init__(self, decision = 'deny', updatedObj = None, updates = []):
        self.decision = decision        # deny or permit
        self.updatedObj = updatedObj    # object that will be updated
        self.updates = updates          # [<attr1, value1>, <attr2, value2>, ..]

def apply_Operation(old_val_of_attr,operation):
    #do processing
    return old_val_of_attr

def evaluate(rule, req):
    return Result()
    decision = "deny"
    updatedObj = None
    updates = dict()
    '''
    req: readAttr[1] = {1_attr1:ver, 1_attr2:ver,....} for objects[1]

    '''
    sc = rule.find('subjectCondition')
    rc=rule.find('resourceCondition')
    act=rule.find('action')
    if req.subject == common.obj(req,1):
        '''
        readAttr[1] refers to all subject attributes
        '''
        count_match_sub_attr = 0
        for rule_attr in sc.attrib.keys():
            curr_val_of_attribute = req.readAttr[1][rule_attr].value
            val_to_match_against = sc.attrib[rule_attr]
            if curr_val_of_attribute == val_to_match_against:
                count_match_sub_attr += 1
        if count_match_sub_attr != len(sc.attrib.keys()):
            result = Result(decision,updatedObj,updates)
            return Result

        count_match_sub_attr = 0
        for rule_attr in rc.attrib.keys():
            curr_val_of_attribute = req.readAttr[2][rule_attr].value
            val_to_match_against = rc.attrib[rule_attr]
            if curr_val_of_attribute == val_to_match_against:
                count_match_sub_attr += 1

        if count_match_sub_attr != len(rc.attrib.keys()):
            result = Result(decision,updatedObj,updates)
            return Result
        sUpdate=rule.find('subjectUpdate')
        rUpdate=rule.find('resourceUpdate')
        if sUpdate == None and rUpdate == None:
            result = Result('permit',updatedObj,updates)
            return Result
        if sUpdate != None:
            updatedObj = req.subject
            for attribute_to_update in sUpdate.attrib:
                old_val_of_attr = req.readAttr[1][attribute_to_update].value
                operation = sUpdate.attrib[attribute_to_update]
                updates[attribute_to_update]=apply_Operation(old_val_of_attr,operation) #returns updated value
            result = Result('permit',updatedObj,updates)
            return result
        else:
            updatedObj = req.resource
            for attribute_to_update in rUpdate.attrib:
                old_val_of_attr = req.readAttr[2][attribute_to_update].value
                operation = rUpdate.attrib[attribute_to_update]
                updates[attribute_to_update]=apply_Operation(old_val_of_attr,operation) #returns updated value
            result = Result('permit',updatedObj,updates)
            return result
        
    else:
        '''
        readAttr[1] refers to all resource attributes
        '''
        count_match_sub_attr = 0
        for rule_attr in rc.attrib.keys():
            curr_val_of_attribute = req.readAttr[1][rule_attr].value
            val_to_match_against = rc.attrib[rule_attr]
            if curr_val_of_attribute == val_to_match_against:
                count_match_sub_attr += 1
        if count_match_sub_attr != len(rc.attrib.keys()):
            result = Result(decision,updatedObj,updates)
            return Result

        count_match_sub_attr = 0
        for rule_attr in sc.attrib.keys():
            curr_val_of_attribute = req.readAttr[2][rule_attr].value
            val_to_match_against = sc.attrib[rule_attr]
            if curr_val_of_attribute == val_to_match_against:
                count_match_sub_attr += 1

        if count_match_sub_attr != len(sc.attrib.keys()):
            result = Result(decision,updatedObj,updates)
            return Result
        
        sUpdate=rule.find('subjectUpdate')
        rUpdate=rule.find('resourceUpdate')
        if sUpdate == None and rUpdate == None:
            result = Result('permit',updatedObj,updates)
            return Result
        if sUpdate != None:
            updatedObj = req.subject
            for attribute_to_update in sUpdate.attrib:
                old_val_of_attr = req.readAttr[2][attribute_to_update].value
                operation = sUpdate.attrib[attribute_to_update]
                updates[attribute_to_update]=apply_Operation(old_val_of_attr,operation) #returns updated value
            result = Result('permit',updatedObj,updates)
            return result
        else:
            updatedObj = req.resource
            for attribute_to_update in rUpdate.attrib:
                old_val_of_attr = req.readAttr[1][attribute_to_update].value
                operation = rUpdate.attrib[attribute_to_update]
                updates[attribute_to_update]=apply_Operation(old_val_of_attr,operation) #returns updated value
            result = Result('permit',updatedObj,updates)
            return result
    '''

     tree = ET.parse('policy-example.xml')
        root = tree.getroot()
        policy = False
        subject_update = {}
        resource_update = {}

        for rule in root.iter('rule'):
            match = 0
            sc=rule.find('subjectCondition')
            if len(sc.attrib) == len(temp_db["subject"]):
                for key in sc.attrib:
                    if sc.attrib[key][0] == '>' or sc.attrib[key][0] == '<' or sc.attrib[key][0] == '=':
                        ans = eval(str(temp_db["subject"][key])+str(sc.attrib[key]))
                        if ans == True:
                            match = match + 1
                    elif temp_db["subject"][key] == sc.attrib[key]:
                        match = match + 1
                
            rc=rule.find('resourceCondition')
            if len(rc.attrib) == len(temp_db["resource"]):
                for key in rc.attrib:
                    if rc.attrib[key][0] == '>' or rc.attrib[key][0] == '<' or rc.attrib[key][0] == '=':
                        ans = eval(str(temp_db["resource"][key])+str(rc.attrib[key]))
                        if ans == True:
                            match = match + 1
                    elif temp_db["resource"][key] == rc.attrib[key]:
                        match = match + 1
                
            act=rule.find('action')
            for key in act.attrib:
                    if temp_db["action"][key] == act.attrib[key]:
                        match = match + 1
                
            if match == len(sc.attrib) + len(rc.attrib) + len(act.attrib):
                su=rule.find('subjectUpdate')
                if su != None:
                    for key in su.attrib:
                        if su.attrib[key][0] == '+' or su.attrib[key][0] == '-' or su.attrib[key][0] == '*' or su.attrib[key][0] == '/':
                            subject_update[key] = eval(str(temp_db["subject"][key])+str(su.attrib[key]))
                        else:
                            subject_update[key] = su.attrib[key]

                ru=rule.find('resourceUpdate')
                if ru != None:
                    for key in ru.attrib:
                        if ru.attrib[key][0] == '+' or ru.attrib[key][0] == '-' or ru.attrib[key][0] == '*' or ru.attrib[key][0] == '/' or ru.attrib[key][0] == '=':
                            if ru.attrib[key][0] == '+':
                                resource_update[key] = int(temp_db["resource"][key]) + 1
                            elif ru.attrib[key][0] == '-':
                                resource_update[key] = int(temp_db["resource"][key]) - 1
                            
                        else:
                            resource_update[key] = ru.attrib[key]
                    
                policy = True
                break
        
        if policy == False:
            return (False,{},{})
        else:
            return (True,subject_update,resource_update)
    '''

def staticAnalysis(req):
    tree = ET.parse(THIS_DIR + '/../policy-example.xml')
    root = tree.getroot()
    rules_match = 0
    subj_attributes = {}
    res_attributes = {}
    R = []
    for rule in root.iter('rule'):
        rc = rule.find('resourceCondition').attrib["type"]
        act = rule.find('action').attrib["name"]
        sc = rule.find('subjectCondition').attrib["type"]
        subject = req.subject
        resource = req.resource

        if sc == subject.type and rc == resource.type and act == req.action:
            R.append(rule)
    return R

def _add_attrs(attr, d):
    if d:
        attr += list(d)

def getAttrNeeded(rule, type):
    attrs = []
    if type == common.ObjectTypeEnum.SUBJECT:
        sc_attribs = rule.find('subjectCondition').attrib.keys()
        _add_attrs(attrs, sc_attribs)
        sub_write=rule.find('subjectUpdate')
        _add_attrs(attrs, sub_write)
    else:
        rc_attribs = rule.find('resourceCondition').attrib.keys()
        _add_attrs(attrs, rc_attribs)
        res_write=rule.find('resourceUpdate')
        _add_attrs(attrs, res_write)
    return attrs

class Worker(process):
    def setup(coords_list, db, requestNo):
        self.q = queue.Queue()

    def readFromDB(R, objs, attr_from_db, rule_no):
        for i in [1, 2]:
            unique_db_req = str(R.id) + str(rule_no) + str(i)
            output("Sending Read to Db: ", unique_db_req)
            send(('Read', unique_db_req, objs[i-1], attr_from_db[i], R.ts), to=self.db)
            await(some(received(('ReadDbResponse', id, newR)), has=(id==unique_db_req)))
            output("Received response from Db: ", unique_db_req)
            for attr in newR.keys():
                R.readAttr[i][attr] = newR[attr]
        return R

    def doWork(work):
        rules = work['rules']
        R = work['request']
        output("Proceeding to Work: ", R)
        p= work['fromProcess']
        coords_list = work['coords_list']
        o1 = common.obj(R, 1)
        o2 = common.obj(R, 2)
        rule_no = 0
        for rule in rules:
            attr_list = {}
            if o1 == R.subject:
                attr_list[1] = getAttrNeeded(rule, common.ObjectTypeEnum.SUBJECT)
                attr_list[2] = getAttrNeeded(rule, common.ObjectTypeEnum.RESOURCE)
            else:
                attr_list[2] = getAttrNeeded(rule, common.ObjectTypeEnum.SUBJECT)
                attr_list[1] = getAttrNeeded(rule, common.ObjectTypeEnum.RESOURCE)

            attr_from_db = {1:[], 2: []}
            for i in [1,2]:
                for attrs in attr_list[i]:
                    if attrs in R.cachedUpdates[i] and R.cachedUpdates[i][attrs].value != None:
                        if attrs not in R.readAttr[i]:
                            R.readAttr[i][attrs] = {}
                        R.readAttr[i][attr] = cachedUpdates[n][attrs]
                    else:
                        attr_from_db[i] += [attrs]
            R = readFromDB(R, [o1,o2], attr_from_db, rule_no)
            result = evaluate(rule, R)
            if result.decision == 'permit' or result.decision == 'deny':
                            break
            rule_no += 1
        if result.decision == None:
            R.decision = 'deny'
        else:
            R.decision = result.decision

        if result.updatedObj == None:
            # Read Request
            R.updatedObj = -1
            R.rdOnlyObj = -1
            R.updates = []
            send(('Response', R), to=R.client)
            output("Read Only Request. Sending request to client: ", R)
            for i in [1, 2]:
                send(('ReadAttr', R, i), to=common.coord(common.obj(R,i), coords_list))
        else:
            # Write Request
            if result.updatedObj == common.obj(R, 1):
                R.updatedObj = 1
                R.rdOnlyObj = 2
            else:
                R.updatedObj = 2
                R.rdOnlyObj = 1
            R.updates = result.updates
            send(('Result', R), to=coord(result.updatedObj))

    def run():
        while True:
            await(received(('Done')) or not self.q.empty())
            if not self.q.empty():
                doWork(self.q.get())
            else:
                break

    def receive(msg=('Request', R), from_=p):
        output("Request received by worker: ", R)
        rules = staticAnalysis(R)
        work = {}
        work['rules'] = rules
        work['request'] = R
        work['fromProcess'] = p
        work['coords_list'] = self.coords_list
        self.q.put(work)
