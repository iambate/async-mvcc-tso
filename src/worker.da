import xml.etree.ElementTree as ET
import os
import sys
import queue
THIS_DIR = os.path.dirname(os.path.realpath(__file__))
sys.path.append(THIS_DIR + "/..")
from config import master_config
common = import_da('common')

class Result:
    def __init__(decision = 'deny', updatedObj = None, updates = []):
        self.decision = decision        # deny or permit
        self.updatedObj = updatedObj    # object that will be updated
        self.updates = updates          # [<attr1, value1>, <attr2, value2>, ..]

def evaulate(rule, req):
    return Result()

def staticAnalysis(req):
    tree = ET.parse(THIS_DIR + '/../policy-example.xml')
    root = tree.getroot()
    rules_match = 0
    subj_attributes = {}
    res_attributes = {}
    R = []
    for rule in root.iter('rule'):
        rc = rule.find('resourceCondition').attrib["type"]
        act = rule.find('action').attrib["name"]
        sc = rule.find('subjectCondition').attrib["type"]
        subject = req.subject
        resource = req.resource

        if sc == subject.type and rc == resource.type and act == req.action:
            R.append(rule)
    return R

def _add_attrs(attr, d):
    if d:
        attr += list(d)

def getAttrNeeded(rule, type):
    attrs = []
    if type == common.ObjectTypeEnum.SUBJECT:
        sc_attribs = rule.find('subjectCondition').attrib.keys()
        _add_attrs(attrs, sc_attribs)
        sub_write=rule.find('subjectUpdate')
        _add_attrs(attrs, sub_write)
    else:
        rc_attribs = rule.find('resourceCondition').attrib.keys()
        _add_attrs(attrs, rc_attribs)
        res_write=rule.find('resourceUpdate')
        _add_attrs(attrs, res_write)
    return attrs

class Worker(process):
    def setup(coords_list, db, requestNo):
        self.q = queue.Queue()

    def readFromDB(R, attr_from_db, rule_no):
        for i in [1, 2]:
            unique_db_req = str(R.id) + str(rule_no) + str(i) 
            send(('Read', unique_db_req, attr_from_db[i]), to=self.db)
            await(some(received(('ReadDbResponse', unique_db_req, newR))))
            for attr in newR:
                if attr not in R.readAttr[i]:
                    R.readAttr[i][attr] = {}
                R.readAttr[i][attr] = newR[attr]
        return R

    def doWork(work):
        rules = work['rules']
        R = work['request']
        p= work['fromProcess']
        coords_list = work['coords_list']
        o = common.obj(R, 1)
        rule_no = 0
        for rule in rules:
            attr_list = {}
            if o == R.subject:
                attr_list[1] = getAttrNeeded(rule, common.ObjectTypeEnum.SUBJECT)
                attr_list[2] = getAttrNeeded(rule, common.ObjectTypeEnum.RESOURCE)
            else:
                attr_list[2] = getAttrNeeded(rule, common.ObjectTypeEnum.SUBJECT)
                attr_list[1] = getAttrNeeded(rule, common.ObjectTypeEnum.RESOURCE)

            attr_from_db = {1:[], 2: []}
            for i in [1,2]:
                for attrs in attr_list[i]:
                    if attrs in R.cachedUpdates[i] and R.cachedUpdates[i][attrs].value != None:
                        if attrs not in R.readAttr[i]:
                            R.readAttr[i][attrs] = {}
                        R.readAttr[i][attr] = cachedUpdates[n][attrs]
                    else:
                        attr_from_db[i] += attrs
            R = readFromDB(R, attr_from_db, rule_no)
            result = evalute(rule, R)
            if result.decision == 'permit' or result.decision == 'deny':
                            break
            rule_no += 1
        # Remove duplicates
        l = list(set(R.readAttr[1]))
        R.readAttr[1] = l
        l = list(set(R.readAttr[2]))
        R.readAttr[2] = l
        if result.decision == None:
            req.decision = 'deny'
        else:
            req.decision = result.decision

        if result.updatedObj == None:
            # Read Request
            R.updatedObj = -1
            R.rdOnlyObj = -1
            R.updates = []
            send(('Response', R), to=R.client)
            for i in [1, 2]:
                send(('ReadAttr', R, i), to=common.coord(common.obj(R,i), coords_list))
        else:
            # Write Request
            if result.updatedObj == common.obj(R, 1):
                R.updatedObj = 1
                R.rdOnlyObj = 2
            else:
                R.updatedObj = 2
                R.rdOnlyObj = 1
            R.updates = result.updates
            send(('Result', R), to=coord(result.updatedObj))

    def run():
        while True:
            await(received(('Done')) or not self.q.empty())
            if not self.q.empty():
                doWork(self.q.get())
            else:
                break

    def receive(msg=('RequestFromCoord', R), from_=p):
        rules = staticAnalysis(R)
        work = {}
        work['rules'] = rules
        work['request'] = R
        work['fromProcess'] = p
        work['coords_list'] = self.coords_list
        self.q.put(work)
