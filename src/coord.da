import commonpy
import copy
import logging
import random
import os
import sys
import time
THIS_DIR = os.path.dirname(os.path.realpath(__file__))
sys.path.append(THIS_DIR + "/..")
from config import master_config
common = import_da('common')

CACHE = {}

def latestVersionBefore(x, attr, ts):
    global CACHE
    prevI = []
    if x.id in CACHE and attr in CACHE[x.id]:
        prevI = commonpy.max_version((list(i for i in CACHE[x.id][attr] if i.wts < ts)))

    if prevI == []:
        if x.id not in CACHE:
            CACHE[x.id] = {}
        if attr not in CACHE[x.id]:
            CACHE[x.id][attr] = []
        CACHE[x.id][attr].insert(0, common.Versions())
        prevI = CACHE[x.id][attr][0]
    return prevI


def cachedUpdates(x, req):
    cu = {}
    l = list(set(common.mightReadAttr(x, req)) | set(common.defReadAttr(x,req)))
    for attrs in l:
        attrVersion = latestVersionBefore(x, attrs, req.ts)
        cu[attrs] = copy.deepcopy(attrVersion)
        #cu = {attr1:<version> ,attr2:<version>,..}
    return cu



class Coord(process):
    def setup(coords_list, workers_list, dbs_list, requestNo):
        global CACHE
        self._CACHE = CACHE
        self.sessionID = common.now()
        self.logger = logging.getLogger(__name__)
        sys.setrecursionlimit(10000)

    def run():
        await(received("Done"))

    def print_cache(printstr,req):
        #global CACHE
        output(printstr," ",req.id," ",req.ts,"\n")
        for i in self._CACHE:
            self.logger.debug("\n",i,":","\n")
            for j in self._CACHE[i]:
                self.logger.debug("\n",j,":")
                for k in self._CACHE[i][j]:
                    self.logger.debug(k.rts," ",k.pendingMightRead)
                    self.logger.debug("\n")

    def check_if_empty(tobeRead):
        count_empty = 0
        for attr in tobeRead:
            if len(latestVersionBefore(x,attr,req.ts).pendingMightWrite) == 0:
                count_empty += 1

        if count_empty == len(tobeRead):
            return True
        return False

    def receive(msg=('Request', req, n), from_=p):
        x = common.obj(req,n)
        if n == 1:
            req.ts = common.now()
        tobeRead = list(set(common.mightReadAttr(x, req)) | set(common.defReadAttr(x,req)) | set(common.mightWriteAttr(x, req)))
        self.logger.debug("Start waiting before proceeding to work: %s", str(req))
        await(check_if_empty(tobeRead) == True)
        '''
        while True:
            count_empty = 0
            for attr in tobeRead:
                if len(latestVersionBefore(x,attr,req.ts).pendingMightWrite) == 0:
                    count_empty += 1

            if count_empty == len(tobeRead):
                break
        '''
        self.logger.debug("Stop waiting before proceeding to work: %s", str(req))


        if (len(common.mightWriteObj(req)) == 0): #its a read only req
            for attr in common.defReadAttr(x, req):
                latestVersionBefore(x, attr, req.ts).rts = req.ts
        else:
            for attr in common.defReadAttr(x,req):
                latestVersionBefore(x, attr, req.ts).pendingMightRead.append(req.id)
        '''
        if req.restarted == True:
            self.logger.info("Returning restarted True: %s", req)
            return
        '''
        for attr in common.mightWriteAttr(x, req):
            latestVersionBefore(x, attr, req.ts).pendingMightWrite.append(req.id)

        for attr in common.mightReadAttr(x, req):
            latestVersionBefore(x, attr, req.ts).pendingMightRead.append(req.id)
        output("STATUS OF cache AFTER 1ST ARRIVAL OF req with reqid:",req.id,"reqts:",req.ts)
        #output("pmr of latestversionbefore")
        for i in self._CACHE:
            output(str(i),":")
            for j in self._CACHE[i]:
                output(j,":")
                for k in self._CACHE[i][j]:
                    output(str(k.rts)," ",k.pendingMightRead,k.pendingMightWrite)
        #output("")

        #print_cache("ro req, updating rts or pendingmightreads for all its defreadattr",req)
        req.cachedUpdates[n] = cachedUpdates(x, req)
        if n == 1:
            send(('Request',req,2),to=common.coord(common.obj(req,2), coords_list))
        else:
            send(('Request',req),to=workers_list[common.hash(req.id, len(coords_list))])

    def receive(msg=('ReadAttr', req, i)):
        self.logger.debug("Entering received a ReadAttr request for object: %d, Request: "+ str(req), i)
        x = common.obj(req, i)
        for attr in common.mightReadAttr(x, req):
            v = latestVersionBefore(x, attr, req.ts)
            if req.id in v.pendingMightRead:
                self.logger.debug("ReadAttr mightRead :%s", v)
                v.pendingMightRead.remove(req.id)
            if attr in req.readAttr[i]:
                v.rts = req.ts
        for attr in common.mightWriteAttr(x, req):
            v = latestVersionBefore(x, attr, req.ts)
            if req.id in v.pendingMightRead:
                self.logger.debug("ReadAttr mightWrite :%s", v)
                v.pendingMightRead.remove(req.id)

        output("UPDATING CACHE AFTER REQ COMPLETION OF req with reqid:",req.id,"reqts:",req.ts)
        #output("pmr of latestversionbefore")
        for i in self._CACHE:
            output(str(i),":")
            for j in self._CACHE[i]:
                output(j,":")
                for k in self._CACHE[i][j]:
                    output(str(k.rts)," ",k.pendingMightRead,k.pendingMightWrite)
        self.logger.debug("Exiting received a ReadAttr request for object: %d, Request: "+ str(req), i)

    def checkForConflicts(x, req):
        self.logger.debug("In checkForConflict: %s", (req))
        for attr in req.updates.keys():
            v = latestVersionBefore(x,attr,req.ts)
            self.logger.debug("Version: %s", str(v))
            if v.rts > req.ts:
                return True
        return False

    def receive(msg=('Result',req)):
        self.logger.debug("Entering CACHE: %s and Results: %s", self._CACHE, req)
        if req.ts < self.sessionID:
            return
        x = common.obj(req,req.updatedObj)
        conflict = checkForConflicts(x, req)

        if conflict == False:
            for attr in req.updates.keys():
                latestVersionBefore(x, attr, req.ts).pendingMightWrite.append(req.id)

            start_timer = common.now()
            timeout = 2 * random.random()

            '''
            await((forall attr in req.updates.keys():
                  
                  (latestVersionBefore(x,attr,req.ts).pendingMightRead.empty() == True) or
                  
                  (len(latestVersionBefore(x,attr,req.ts).pendingMightRead) == 1 and
                
                    req.id in latestVersionBefore(x,attr,req.ts).pendingMightRead)), (common.now() - start_timer >= timeout))
            '''
            timed_out = False
            while True:
                if common.now() - start_timer >= timeout:
                    timed_out = True
                    break
                count_empty = 0
                for attr in req.updates.keys():
                    if len(latestVersionBefore(x,attr,req.ts).pendingMightRead) == 0 \
                    or (len(latestVersionBefore(x,attr,req.ts).pendingMightRead) == 1 and \
                    req.id in latestVersionBefore(x,attr,req.ts).pendingMightRead):
                        count_empty += 1
                if count_empty == len(req.updates):
                    break
 
            if timed_out == True:
                self.logger.debug("Exiting CACHE: %s and Results: %s", self._CACHE, req)
                self.logger.info("Restart Request due to timeout %s: ", req)
                send(('Restart', req, 1), to=common.coord(common.obj(req,1), coords_list))
                send(('Restart', req, 2), to=common.coord(common.obj(req,2), coords_list))
                return


            conflict = checkForConflicts(x, req)

            if not conflict:
                send(("UpdateDatabase",req.updatedObj,req.updates,req.ts),to=dbs_list[0])
                for attr in req.updates.keys():
                    v = common.Versions(req.ts,req.ts,req.updates[attr])
                    self._CACHE[x.id][attr].append(v)
                self.logger.debug("Updating to CACHE in Result version: %s", str(v) )

                AllAttrsRead = list(set(common.mightReadAttr(x, req)) | set(common.defReadAttr(x,req)))
                for attr in AllAttrsRead:
                    v = latestVersionBefore(x,attr,req.ts)
                    self.logging.debug("No conflict: %s", v)
                    # Verify Again
                    if req.id in v.pendingMightRead:
                        v.pendingMightRead.remove(req.id)
                        #v.rts = req.ts
                    if attr in req.readAttr[req.updatedObj]:
                        v.rts = req.ts
                output("UPDATED READATTR RTS,REMOVED FROM PENDINGMIGHTREAD reqid:",req.id,"reqts:",req.ts)
                #output("pmr of latestversionbefore")
                for i in self._CACHE:
                    output(str(i),":")
                    for j in self._CACHE[i]:
                        output(j,":")
                        for k in self._CACHE[i][j]:
                            output(str(k.rts)," ",k.pendingMightRead,k.pendingMightWrite)
                #output("xxxxxxxxx end new xxxxxxx")
                #print_cache("req evaluated without conflicts,updating rts of its read attrs,",req)
                send(('Response', req), to=req.client)
                send(('ReadAttr', req, 1), to=common.coord(common.obj(req,1), coords_list))
                send(('ReadAttr', req, 2), to=common.coord(common.obj(req,2), coords_list))
            else:
                self.logger.info("Restart Request due to second conflict %s: ", req)
                send(('Restart', req, 1), to=common.coord(common.obj(req,1), coords_list))
                send(('Restart', req, 2), to=common.coord(common.obj(req,2), coords_list))
        else:
            self.logger.info("Restart Request due to first conflict %s: ", req)
            send(('Restart', req, 1), to=common.coord(common.obj(req,1), coords_list))
            send(('Restart', req, 2), to=common.coord(common.obj(req,2), coords_list))
        self.logger.debug("Exiting CACHE: %s and Results: %s", self._CACHE, req)


    def receive(msg=('Restart', req, n)):
        x = common.obj(req, n)
        
        for attr in list(set(common.mightReadAttr(x, req)) | set(common.defReadAttr(x,req))):
            latestVersionBefore(x, attr, req.ts).pendingMightRead.remove(req.id)


        for attr in common.mightWriteAttr(x, req):
            latestVersionBefore(x, attr, req.ts).pendingMightWrite.remove(req.id)
        if n == 2:
            req.restarted = True
            send(('Request', req, 1), to=common.coord(common.obj(req, 1), coords_list))
